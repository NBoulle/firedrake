#! /usr/bin/env python3

import argparse
import json
import os
import sys
import warnings

import dash
from dash import html, dcc
import pandas as pd
import plotly.express as px
import pytest


class InvalidFileError(Exception):
    pass


def run(args):
    _, pytest_args = split_args(sys.argv[1:])
    cmd = ["--benchmark-warmup=on", "--benchmark-only", "--benchmark-autosave"] + pytest_args
    pytest.main(cmd)


def show(args):
    """Launch a web application displaying the benchmark data."""
    app = dash.Dash(__name__)

    data = parse_benchmarks(args.path)
    plots = []
    for benchmark, df in data.groupby("benchmark"):
        fig = plot_benchmark(benchmark, df)
        fig.write_html(f"{benchmark}.html")
        plots.append(dcc.Graph(id=benchmark, figure=fig))

    app.layout = html.Div(children=plots)
    app.run_server()


def export(args):
    """Export benchmark data (so it can be shared)."""
    df = parse_benchmarks(args.path)
    df.to_csv(args.output, index=False)
    print(f"Benchmark data written to {args.output}")


def publish(args):
    raise NotImplementedError


def parse_args():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    run_parser = subparsers.add_parser("run")
    run_parser.set_defaults(func=run)

    show_parser = subparsers.add_parser("show")
    show_parser.add_argument("path", type=str, nargs="+")
    show_parser.set_defaults(func=show)

    export_parser = subparsers.add_parser("export")
    export_parser.add_argument("path", type=str, nargs="+")
    export_parser.add_argument("-o", dest="output", type=str, default="benchmarks-export.csv")
    export_parser.set_defaults(func=export)

    publish_parser = subparsers.add_parser("publish")
    publish_parser.add_argument("path", type=str, nargs="+")
    publish_parser.set_defaults(func=publish)

    args, _ = split_args(sys.argv[1:])
    if not args:
        parser.print_help()
        exit()
    return parser.parse_args(args)


def split_args(argv):
    """Split commandline arguments by '--'."""
    try:
        index = argv.index("--")
    except ValueError:
        index = len(argv)
    return argv[:index], argv[index:]


def parse_benchmarks(paths):
    dfs = []
    for path in paths:
        if os.path.isdir(path):
            for file in os.listdir(path):
                try:
                    dfs.append(parse_benchmark(os.path.join(path, file)))
                except InvalidFileError:
                    # skip invalid files if looping through a directory
                    pass
        elif os.path.isfile(path):
            # read exported files here
            if os.path.splitext(path)[1] == ".csv":
                dfs.append(pd.read_csv(path))
            else:
                dfs.append(parse_benchmark(path))
    df = pd.concat(dfs, ignore_index=True)

    df.sort_values(by="commit_time", inplace=True, ignore_index=True)
    for duplicate in df[df.duplicated(subset=["commit_id", "dirty"], keep=False)].itertuples():
        warnings.warn(
            f"Duplicate benchmark results found for {duplicate.commit_id}, only the "
            "last will be used"
        )
    df.drop_duplicates(subset=["benchmark", "commit_id", "dirty"], keep="last", inplace=True)
    return df


def parse_benchmark(file):
    """Parse a benchmark file into a dataframe."""
    try:
        with open(file) as f:
            raw = json.load(f)

        data = []
        machine_info = "_".join(
            raw["machine_info"][key] for key in ["node", "machine", "release", "system"]
        )
        for benchmark in raw["benchmarks"]:
            data.append({
                "benchmark": benchmark["fullname"],
                "mean": benchmark["stats"]["mean"],
                "min": benchmark["stats"]["min"],
                "max": benchmark["stats"]["max"],
            })

        # add shared columns
        return pd.DataFrame(data).assign(
            filename= file,
            machine=machine_info,
            commit_id=raw["commit_info"]["id"],
            commit_time=raw["commit_info"]["time"],
            dirty=raw["commit_info"]["dirty"],
            branch=raw["commit_info"]["branch"],
        )
    except:
        raise InvalidFileError(f"{file} does not appear to be a benchmark data file")


def plot_benchmark(benchmark: str, df: pd.DataFrame):
    """Plot a benchmark.

    Parameters
    ----------
    benchmark:
        The name of the benchmark.
    df:
        A `pandas` dataframe containing the benchmark data.
    """
    return px.line(
        df, title=benchmark,
        x="commit_time", y="mean", error_y_minus=df["min"], error_y=df["max"],
        color="machine", markers=True, hover_data=["commit_id", "branch"],
        labels={"mean": "time"},
    )


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
